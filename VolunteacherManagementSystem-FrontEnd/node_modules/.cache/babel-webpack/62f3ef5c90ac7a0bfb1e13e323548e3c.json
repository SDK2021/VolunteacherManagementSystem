{"ast":null,"code":"import _classCallCheck from \"C:/Users/Suhanee Mavar/Desktop/VMS/VolunteacherManagementSystem-FrontEnd/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/Suhanee Mavar/Desktop/VMS/VolunteacherManagementSystem-FrontEnd/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { fromEvent, of } from 'rxjs';\nimport { filter, map, mergeMap, tap, throttleTime } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/ngx-ins-utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  /** @type {?} */\n  var hasWindow = window && !!window.document && window.document.documentElement;\n  /** @type {?} */\n\n  var container = hasWindow && scrollWindow ? window : defaultElement;\n\n  if (selector) {\n    /** @type {?} */\n    var containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n\n  return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\n\n\nfunction findElement(selector, customRoot, fromRoot) {\n  /** @type {?} */\n  var rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\n\n\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\n\n\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/axis-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\n/** @type {?} */\n\nvar HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\n\nvar AxisResolver = /*#__PURE__*/function () {\n  /**\n   * @param {?=} vertical\n   */\n  function AxisResolver() {\n    var vertical = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    _classCallCheck(this, AxisResolver);\n\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(AxisResolver, [{\n    key: \"clientHeightKey\",\n    value: function clientHeightKey() {\n      return this.propsMap.clientHeight;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"offsetHeightKey\",\n    value: function offsetHeightKey() {\n      return this.propsMap.offsetHeight;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"scrollHeightKey\",\n    value: function scrollHeightKey() {\n      return this.propsMap.scrollHeight;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"pageYOffsetKey\",\n    value: function pageYOffsetKey() {\n      return this.propsMap.pageYOffset;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"offsetTopKey\",\n    value: function offsetTopKey() {\n      return this.propsMap.offsetTop;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"scrollTopKey\",\n    value: function scrollTopKey() {\n      return this.propsMap.scrollTop;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"topKey\",\n    value: function topKey() {\n      return this.propsMap.top;\n    }\n  }]);\n\n  return AxisResolver;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/event-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @param {?} alwaysCallback\n * @param {?} shouldFireScrollEvent\n * @param {?} isTriggeredCurrentTotal\n * @return {?}\n */\n\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/position-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction createResolver(_ref) {\n  var windowElement = _ref.windowElement,\n      axis = _ref.axis;\n  return createResolverWithContainer({\n    axis: axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\n\n\nfunction createResolverWithContainer(resolver, windowElement) {\n  /** @type {?} */\n  var container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return Object.assign(Object.assign({}, resolver), {\n    container: container\n  });\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\n\n\nfunction isElementWindow(windowElement) {\n  /** @type {?} */\n  var isWindow = ['Window', 'global'].some(\n  /**\n  * @param {?} obj\n  * @return {?}\n  */\n  function (obj) {\n    return Object.prototype.toString.call(windowElement).includes(obj);\n  });\n  return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\n\n\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\n\n\nfunction calculatePoints(element, resolver) {\n  /** @type {?} */\n  var height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\n\n\nfunction calculatePointsForWindow(height, element, resolver) {\n  var axis = resolver.axis,\n      container = resolver.container,\n      isWindow = resolver.isWindow;\n\n  var _extractHeightPropKey = extractHeightPropKeys(axis),\n      offsetHeightKey = _extractHeightPropKey.offsetHeightKey,\n      clientHeightKey = _extractHeightPropKey.clientHeightKey; // scrolled until now / current y point\n\n  /** @type {?} */\n\n\n  var scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow); // total height / most bottom y point\n\n  /** @type {?} */\n\n  var nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  /** @type {?} */\n\n  var totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height: height,\n    scrolled: scrolled,\n    totalToScroll: totalToScroll,\n    isWindow: isWindow\n  };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\n\n\nfunction calculatePointsForElement(height, element, resolver) {\n  var axis = resolver.axis,\n      container = resolver.container; // perhaps use container.offsetTop instead of 'scrollTop'\n\n  /** @type {?} */\n\n  var scrolled = container[axis.scrollTopKey()];\n  /** @type {?} */\n\n  var totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height: height,\n    scrolled: scrolled,\n    totalToScroll: totalToScroll,\n    isWindow: false\n  };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\n\n\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction extractHeightForElement(_ref2) {\n  var container = _ref2.container,\n      isWindow = _ref2.isWindow,\n      axis = _ref2.axis;\n\n  var _extractHeightPropKey2 = extractHeightPropKeys(axis),\n      offsetHeightKey = _extractHeightPropKey2.offsetHeightKey,\n      clientHeightKey = _extractHeightPropKey2.clientHeightKey;\n\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\n\n\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    /** @type {?} */\n    var docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\n\n\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  /** @type {?} */\n  var topKey = axis.topKey(); // elem = elem.nativeElement;\n\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\n\n\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  /** @type {?} */\n  var pageYOffset = axis.pageYOffsetKey();\n  /** @type {?} */\n\n  var scrollTop = axis.scrollTopKey();\n  /** @type {?} */\n\n  var offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} container\n * @param {?} distance\n * @param {?} scrollingDown\n * @return {?}\n */\n\n\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n  /** @type {?} */\n  var remaining;\n  /** @type {?} */\n\n  var containerBreakpoint;\n\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n  /** @type {?} */\n\n\n  var scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    containerBreakpoint = distance.down / 10;\n  } else {\n    /** @type {?} */\n    var totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    containerBreakpoint = distance.up / 10;\n  }\n  /** @type {?} */\n\n\n  var shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\n\n\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} distance\n * @return {?}\n */\n\n\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  /** @type {?} */\n  var scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown: scrollDown\n  };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scroll\n * @param {?} scrollState\n * @param {?} triggered\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-state.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar ScrollState = /*#__PURE__*/function () {\n  /**\n   * @param {?} __0\n   */\n  function ScrollState(_ref3) {\n    var totalToScroll = _ref3.totalToScroll;\n\n    _classCallCheck(this, ScrollState);\n\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    this.totalToScroll = totalToScroll;\n  }\n  /**\n   * @param {?} position\n   * @return {?}\n   */\n\n\n  _createClass(ScrollState, [{\n    key: \"updateScrollPosition\",\n    value: function updateScrollPosition(position) {\n      return this.lastScrollPosition = position;\n    }\n    /**\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateTotalToScroll\",\n    value: function updateTotalToScroll(totalToScroll) {\n      if (this.lastTotalToScroll !== totalToScroll) {\n        this.lastTotalToScroll = this.totalToScroll;\n        this.totalToScroll = totalToScroll;\n      }\n    }\n    /**\n     * @param {?} scrolledUntilNow\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateScroll\",\n    value: function updateScroll(scrolledUntilNow, totalToScroll) {\n      this.updateScrollPosition(scrolledUntilNow);\n      this.updateTotalToScroll(totalToScroll);\n    }\n    /**\n     * @param {?} scroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateTriggeredFlag\",\n    value: function updateTriggeredFlag(scroll, isScrollingDown) {\n      if (isScrollingDown) {\n        this.triggered.down = scroll;\n      } else {\n        this.triggered.up = scroll;\n      }\n    }\n    /**\n     * @param {?} totalToScroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n\n  }, {\n    key: \"isTriggeredScroll\",\n    value: function isTriggeredScroll(totalToScroll, isScrollingDown) {\n      return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n    }\n  }]);\n\n  return ScrollState;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/services/scroll-register.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} config\n * @return {?}\n */\n\n\nfunction createScroller(config) {\n  var scrollContainer = config.scrollContainer,\n      scrollWindow = config.scrollWindow,\n      element = config.element,\n      fromRoot = config.fromRoot;\n  /** @type {?} */\n\n  var resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  /** @type {?} */\n\n  var scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  /** @type {?} */\n\n  var options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  /** @type {?} */\n\n  var distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(\n  /**\n  * @return {?}\n  */\n  function () {\n    return of(calculatePoints(element, resolver));\n  }), map(\n  /**\n  * @param {?} positionStats\n  * @return {?}\n  */\n  function (positionStats) {\n    return toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance);\n  }), tap(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref4) {\n    var stats = _ref4.stats;\n    return scrollState.updateScroll(stats.scrolled, stats.totalToScroll);\n  }), filter(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref5) {\n    var fire = _ref5.fire,\n        scrollDown = _ref5.scrollDown,\n        totalToScroll = _ref5.stats.totalToScroll;\n    return shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown));\n  }), tap(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref6) {\n    var scrollDown = _ref6.scrollDown,\n        totalToScroll = _ref6.stats.totalToScroll;\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\n/**\n * @param {?} options\n * @return {?}\n */\n\n\nfunction attachScrollEvent(options) {\n  /** @type {?} */\n  var obs = fromEvent(options.container, 'scroll'); // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle));\n  }\n\n  return obs;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} stats\n * @param {?} distance\n * @return {?}\n */\n\n\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  var _getScrollStats = getScrollStats(lastScrollPosition, stats, distance),\n      scrollDown = _getScrollStats.scrollDown,\n      fire = _getScrollStats.fire;\n\n  return {\n    scrollDown: scrollDown,\n    fire: fire,\n    stats: stats\n  };\n}\n/** @type {?} */\n\n\nvar InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n/**\n * @param {?} response\n * @return {?}\n */\n\nfunction toInfiniteScrollAction(response) {\n  var scrollDown = response.scrollDown,\n      currentScrollPosition = response.stats.scrolled;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition: currentScrollPosition\n    }\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/modules/infinite-scroll.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar InfiniteScrollDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} element\n   * @param {?} zone\n   */\n  function InfiniteScrollDirective(element, zone) {\n    _classCallCheck(this, InfiniteScrollDirective);\n\n    this.element = element;\n    this.zone = zone;\n    this.scrolled = new EventEmitter();\n    this.scrolledUp = new EventEmitter();\n    this.infiniteScrollDistance = 2;\n    this.infiniteScrollUpDistance = 1.5;\n    this.infiniteScrollThrottle = 150;\n    this.infiniteScrollDisabled = false;\n    this.infiniteScrollContainer = null;\n    this.scrollWindow = true;\n    this.immediateCheck = false;\n    this.horizontal = false;\n    this.alwaysCallback = false;\n    this.fromRoot = false;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(InfiniteScrollDirective, [{\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      if (!this.infiniteScrollDisabled) {\n        this.setup();\n      }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(_ref7) {\n      var infiniteScrollContainer = _ref7.infiniteScrollContainer,\n          infiniteScrollDisabled = _ref7.infiniteScrollDisabled,\n          infiniteScrollDistance = _ref7.infiniteScrollDistance;\n\n      /** @type {?} */\n      var containerChanged = inputPropChanged(infiniteScrollContainer);\n      /** @type {?} */\n\n      var disabledChanged = inputPropChanged(infiniteScrollDisabled);\n      /** @type {?} */\n\n      var distanceChanged = inputPropChanged(infiniteScrollDistance);\n      /** @type {?} */\n\n      var shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n\n      if (containerChanged || disabledChanged || distanceChanged) {\n        this.destroyScroller();\n\n        if (shouldSetup) {\n          this.setup();\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this = this;\n\n      if (hasWindowDefined()) {\n        this.zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this.disposeScroller = createScroller({\n            fromRoot: _this.fromRoot,\n            alwaysCallback: _this.alwaysCallback,\n            disable: _this.infiniteScrollDisabled,\n            downDistance: _this.infiniteScrollDistance,\n            element: _this.element,\n            horizontal: _this.horizontal,\n            scrollContainer: _this.infiniteScrollContainer,\n            scrollWindow: _this.scrollWindow,\n            throttle: _this.infiniteScrollThrottle,\n            upDistance: _this.infiniteScrollUpDistance\n          }).subscribe(\n          /**\n          * @param {?} payload\n          * @return {?}\n          */\n          function (payload) {\n            return _this.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              return _this.handleOnScroll(payload);\n            });\n          });\n        });\n      }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n\n  }, {\n    key: \"handleOnScroll\",\n    value: function handleOnScroll(_ref8) {\n      var type = _ref8.type,\n          payload = _ref8.payload;\n\n      switch (type) {\n        case InfiniteScrollActions.DOWN:\n          return this.scrolled.emit(payload);\n\n        case InfiniteScrollActions.UP:\n          return this.scrolledUp.emit(payload);\n\n        default:\n          return;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.destroyScroller();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"destroyScroller\",\n    value: function destroyScroller() {\n      if (this.disposeScroller) {\n        this.disposeScroller.unsubscribe();\n      }\n    }\n  }]);\n\n  return InfiniteScrollDirective;\n}();\n\nInfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) {\n  return new (t || InfiniteScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nInfiniteScrollDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: InfiniteScrollDirective,\n  selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n  inputs: {\n    infiniteScrollDistance: \"infiniteScrollDistance\",\n    infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n    infiniteScrollThrottle: \"infiniteScrollThrottle\",\n    infiniteScrollDisabled: \"infiniteScrollDisabled\",\n    infiniteScrollContainer: \"infiniteScrollContainer\",\n    scrollWindow: \"scrollWindow\",\n    immediateCheck: \"immediateCheck\",\n    horizontal: \"horizontal\",\n    alwaysCallback: \"alwaysCallback\",\n    fromRoot: \"fromRoot\"\n  },\n  outputs: {\n    scrolled: \"scrolled\",\n    scrolledUp: \"scrolledUp\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nInfiniteScrollDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: NgZone\n  }];\n};\n\nInfiniteScrollDirective.propDecorators = {\n  scrolled: [{\n    type: Output\n  }],\n  scrolledUp: [{\n    type: Output\n  }],\n  infiniteScrollDistance: [{\n    type: Input\n  }],\n  infiniteScrollUpDistance: [{\n    type: Input\n  }],\n  infiniteScrollThrottle: [{\n    type: Input\n  }],\n  infiniteScrollDisabled: [{\n    type: Input\n  }],\n  infiniteScrollContainer: [{\n    type: Input\n  }],\n  scrollWindow: [{\n    type: Input\n  }],\n  immediateCheck: [{\n    type: Input\n  }],\n  horizontal: [{\n    type: Input\n  }],\n  alwaysCallback: [{\n    type: Input\n  }],\n  fromRoot: [{\n    type: Input\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(InfiniteScrollDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    scrolled: [{\n      type: Output\n    }],\n    scrolledUp: [{\n      type: Output\n    }],\n    infiniteScrollDistance: [{\n      type: Input\n    }],\n    infiniteScrollUpDistance: [{\n      type: Input\n    }],\n    infiniteScrollThrottle: [{\n      type: Input\n    }],\n    infiniteScrollDisabled: [{\n      type: Input\n    }],\n    infiniteScrollContainer: [{\n      type: Input\n    }],\n    scrollWindow: [{\n      type: Input\n    }],\n    immediateCheck: [{\n      type: Input\n    }],\n    horizontal: [{\n      type: Input\n    }],\n    alwaysCallback: [{\n      type: Input\n    }],\n    fromRoot: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/modules/ngx-infinite-scroll.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar InfiniteScrollModule = function InfiniteScrollModule() {\n  _classCallCheck(this, InfiniteScrollModule);\n};\n\nInfiniteScrollModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: InfiniteScrollModule\n});\nInfiniteScrollModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function InfiniteScrollModule_Factory(t) {\n    return new (t || InfiniteScrollModule)();\n  },\n  providers: [],\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InfiniteScrollModule, {\n    declarations: [InfiniteScrollDirective],\n    exports: [InfiniteScrollDirective]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(InfiniteScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [InfiniteScrollDirective],\n      exports: [InfiniteScrollDirective],\n      imports: [],\n      providers: []\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/ngx-infinite-scroll.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngx-infinite-scroll.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { InfiniteScrollDirective, InfiniteScrollModule };","map":{"version":3,"sources":["../../src/services/ngx-ins-utils.ts","../../src/services/axis-resolver.ts","../../src/services/event-trigger.ts","../../src/services/position-resolver.ts","../../src/services/scroll-resolver.ts","../../src/services/scroll-state.ts","../../src/services/scroll-register.ts","../../src/modules/infinite-scroll.directive.ts","../../src/modules/ngx-infinite-scroll.module.ts","../../src/ngx-infinite-scroll.ts","../../public-api.ts","../../ngx-infinite-scroll.ts"],"names":["ScrollResolver.getScrollStats"],"mappings":"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","sourcesContent":["import { ElementRef, SimpleChange } from '@angular/core';\n\nexport function resolveContainerElement(\n  selector: string | any,\n  scrollWindow,\n  defaultElement,\n  fromRoot: boolean\n): any {\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n  if (selector) {\n    const containerIsString =\n      selector && hasWindow && typeof selector === 'string';\n    container = containerIsString\n      ? findElement(selector, defaultElement.nativeElement, fromRoot)\n      : selector;\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n  return container;\n}\n\nexport function findElement(\n  selector: string | any,\n  customRoot: ElementRef | any,\n  fromRoot: boolean\n) {\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n\nexport function inputPropChanged(prop: SimpleChange): boolean {\n  return prop && !prop.firstChange;\n}\n\nexport function hasWindowDefined(): boolean {\n  return typeof window !== 'undefined';\n}\n","const VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\n\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\n\nexport class AxisResolver {\n  private propsMap: any;\n\n  constructor(private vertical: boolean = true) {\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n  topKey() {\n    return this.propsMap.top;\n  }\n}\n","import { IInfiniteScrollEvent, IPositionStats } from '../models';\n\nexport interface IScrollerProps extends IDistanceRange {\n  container: IPositionStats;\n  alwaysCallback: boolean;\n  disabled: boolean;\n}\n\nexport interface ITriggerEvents {\n  down: (event: any) => any;\n  up: (event: any) => any;\n}\n\nexport interface IDistanceRange {\n  down: number;\n  up: number;\n}\n\nexport interface IScrollConfig {\n  alwaysCallback: boolean;\n  shouldFireScrollEvent: boolean;\n}\n\nexport function shouldTriggerEvents(\n  alwaysCallback: boolean,\n  shouldFireScrollEvent: boolean,\n  isTriggeredCurrentTotal: boolean\n) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n  return false;\n}\n","import { ElementRef } from '@angular/core';\n\nimport { ContainerRef, IPositionElements, IPositionStats, IResolver } from '../models';\nimport { AxisResolver } from './axis-resolver';\n\nexport function createResolver({\n  windowElement,\n  axis\n}: IPositionElements): IResolver {\n  return createResolverWithContainer(\n    { axis, isWindow: isElementWindow(windowElement) },\n    windowElement\n  );\n}\n\nexport function createResolverWithContainer(\n  resolver,\n  windowElement: ContainerRef\n) {\n  const container =\n    resolver.isWindow || (windowElement && !windowElement.nativeElement)\n      ? windowElement\n      : windowElement.nativeElement;\n  return { ...resolver, container };\n}\n\nexport function isElementWindow(windowElement: ContainerRef): boolean {\n  const isWindow = ['Window', 'global'].some((obj: string) =>\n    Object.prototype.toString.call(windowElement).includes(obj)\n  );\n  return isWindow;\n}\n\nexport function getDocumentElement(isContainerWindow: boolean, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n\nexport function calculatePoints(element: ElementRef, resolver: IResolver) {\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow\n    ? calculatePointsForWindow(height, element, resolver)\n    : calculatePointsForElement(height, element, resolver);\n}\n\nexport function calculatePointsForWindow(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container, isWindow } = resolver;\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  // scrolled until now / current y point\n  const scrolled =\n    height +\n    getElementPageYOffset(\n      getDocumentElement(isWindow, container),\n      axis,\n      isWindow\n    );\n  // total height / most bottom y point\n  const nativeElementHeight = getElementHeight(\n    element.nativeElement,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n  const totalToScroll =\n    getElementOffsetTop(element.nativeElement, axis, isWindow) +\n    nativeElementHeight;\n  return { height, scrolled, totalToScroll, isWindow };\n}\n\nexport function calculatePointsForElement(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container } = resolver;\n  // perhaps use container.offsetTop instead of 'scrollTop'\n  const scrolled = container[axis.scrollTopKey()];\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return { height, scrolled, totalToScroll, isWindow: false };\n}\n\nexport function extractHeightPropKeys(axis: AxisResolver) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n\nexport function extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}: IResolver) {\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  return getElementHeight(\n    container,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n}\nexport function getElementHeight(\n  elem: any,\n  isWindow: boolean,\n  offsetHeightKey: string,\n  clientHeightKey: string\n) {\n  if (isNaN(elem[offsetHeightKey])) {\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n\nexport function getElementOffsetTop(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const topKey = axis.topKey();\n  // elem = elem.nativeElement;\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n  return (\n    elem.getBoundingClientRect()[topKey] +\n    getElementPageYOffset(elem, axis, isWindow)\n  );\n}\n\nexport function getElementPageYOffset(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const pageYOffset = axis.pageYOffsetKey();\n  const scrollTop = axis.scrollTopKey();\n  const offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n","import { IPositionStats, IScrollState, IScrollerDistance } from '../models';\n\nexport function shouldFireScrollEvent(\n  container: IPositionStats,\n  distance: IScrollerDistance,\n  scrollingDown: boolean\n) {\n  let remaining: number;\n  let containerBreakpoint: number;\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n\n  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n  if (scrollingDown) {\n    remaining =\n      (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    containerBreakpoint = distance.down / 10;\n  } else {\n    const totalHiddenContentHeight =\n      container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    containerBreakpoint = distance.up / 10;\n  }\n\n  const shouldFireEvent: boolean = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n\nexport function isScrollingDownwards(\n  lastScrollPosition: number,\n  container: IPositionStats\n) {\n  return lastScrollPosition < container.scrolled;\n}\n\nexport function getScrollStats(\n  lastScrollPosition: number,\n  container: IPositionStats,\n  distance: IScrollerDistance\n) {\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\n\nexport function updateScrollPosition(\n  position: number,\n  scrollState: IScrollState\n) {\n  return (scrollState.lastScrollPosition = position);\n}\n\nexport function updateTotalToScroll(\n  totalToScroll: number,\n  scrollState: IScrollState\n) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\n\nexport function isSameTotalToScroll(scrollState: IScrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\n\nexport function updateTriggeredFlag(\n  scroll,\n  scrollState: IScrollState,\n  triggered: boolean,\n  isScrollingDown: boolean\n) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\n\nexport function isTriggeredScroll(\n  totalToScroll,\n  scrollState: IScrollState,\n  isScrollingDown: boolean\n) {\n  return isScrollingDown\n    ? scrollState.triggered.down === totalToScroll\n    : scrollState.triggered.up === totalToScroll;\n}\n\nexport function updateScrollState(\n  scrollState: IScrollState,\n  scrolledUntilNow: number,\n  totalToScroll: number\n) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState);\n  // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\n","import { IScrollState, IScrollerDistance } from '../models';\n\nexport class ScrollState implements IScrollState {\n  lastScrollPosition = 0;\n  lastTotalToScroll = 0;\n  totalToScroll = 0;\n  triggered: IScrollerDistance = {\n    down: 0,\n    up: 0\n  };\n\n  constructor({ totalToScroll }) {\n    this.totalToScroll = totalToScroll;\n  }\n\n  updateScrollPosition(position: number) {\n    return (this.lastScrollPosition = position);\n  }\n\n  updateTotalToScroll(totalToScroll: number) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n\n  updateScroll(scrolledUntilNow: number, totalToScroll: number) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n\n  updateTriggeredFlag(scroll, isScrollingDown: boolean) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n\n  isTriggeredScroll(totalToScroll, isScrollingDown: boolean) {\n    return isScrollingDown\n      ? this.triggered.down === totalToScroll\n      : this.triggered.up === totalToScroll;\n  }\n}\n","import { Observable, of, fromEvent } from 'rxjs';\nimport { map, mergeMap, tap, throttleTime, filter } from 'rxjs/operators';\n\nimport * as Models from '../models';\nimport { AxisResolver } from './axis-resolver';\nimport { shouldTriggerEvents } from './event-trigger';\nimport { resolveContainerElement } from './ngx-ins-utils';\nimport { calculatePoints, createResolver } from './position-resolver';\nimport * as ScrollResolver from './scroll-resolver';\nimport { ScrollState } from './scroll-state';\n\nexport function createScroller(config: Models.IScroller) {\n  const { scrollContainer, scrollWindow, element, fromRoot } = config;\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(\n      scrollContainer,\n      scrollWindow,\n      element,\n      fromRoot\n    )\n  });\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  const options: Models.IScrollRegisterConfig = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(\n    mergeMap(() => of(calculatePoints(element, resolver))),\n    map((positionStats: Models.IPositionStats) =>\n      toInfiniteScrollParams(\n        scrollState.lastScrollPosition,\n        positionStats,\n        distance\n      )\n    ),\n    tap(({ stats }: Models.IScrollParams) =>\n      scrollState.updateScroll(stats.scrolled, stats.totalToScroll)\n    ),\n    filter(\n      ({ fire, scrollDown, stats: { totalToScroll } }: Models.IScrollParams) =>\n        shouldTriggerEvents(\n          config.alwaysCallback,\n          fire,\n          scrollState.isTriggeredScroll(totalToScroll, scrollDown)\n        )\n    ),\n    tap(({ scrollDown, stats: { totalToScroll } }: Models.IScrollParams) => {\n      scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }),\n    map(toInfiniteScrollAction)\n  );\n}\n\nexport function attachScrollEvent(\n  options: Models.IScrollRegisterConfig\n): Observable<{}> {\n  let obs = fromEvent(options.container, 'scroll');\n  // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle));\n  }\n  return obs;\n}\n\nexport function toInfiniteScrollParams(\n  lastScrollPosition: number,\n  stats: Models.IPositionStats,\n  distance: Models.IScrollerDistance\n): Models.IScrollParams {\n  const { scrollDown, fire } = ScrollResolver.getScrollStats(\n    lastScrollPosition,\n    stats,\n    distance\n  );\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\n\nexport const InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n\nexport function toInfiniteScrollAction(\n  response: Models.IScrollParams\n): Models.IInfiniteScrollAction {\n  const {\n    scrollDown,\n    stats: { scrolled: currentScrollPosition }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  SimpleChanges\n} from '@angular/core';\nimport {Subscription} from 'rxjs';\n\nimport { IInfiniteScrollEvent, IInfiniteScrollAction } from '../models';\nimport { hasWindowDefined, inputPropChanged } from '../services/ngx-ins-utils';\nimport { createScroller, InfiniteScrollActions } from '../services/scroll-register';\n\n@Directive({\n  selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n})\nexport class InfiniteScrollDirective\n  implements OnDestroy, OnChanges, AfterViewInit {\n  @Output() scrolled = new EventEmitter<IInfiniteScrollEvent>();\n  @Output() scrolledUp = new EventEmitter<IInfiniteScrollEvent>();\n\n  @Input() infiniteScrollDistance: number = 2;\n  @Input() infiniteScrollUpDistance: number = 1.5;\n  @Input() infiniteScrollThrottle: number = 150;\n  @Input() infiniteScrollDisabled: boolean = false;\n  @Input() infiniteScrollContainer: any = null;\n  @Input() scrollWindow: boolean = true;\n  @Input() immediateCheck: boolean = false;\n  @Input() horizontal: boolean = false;\n  @Input() alwaysCallback: boolean = false;\n  @Input() fromRoot: boolean = false;\n\n  private disposeScroller: Subscription;\n\n  constructor(private element: ElementRef, private zone: NgZone) { }\n\n  ngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n\n  ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }: SimpleChanges) {\n    const containerChanged = inputPropChanged(infiniteScrollContainer);\n    const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    const distanceChanged = inputPropChanged(infiniteScrollDistance);\n    const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n      (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n\n  setup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe((payload: any) => this.zone.run(() => this.handleOnScroll(payload)));\n      });\n    }\n  }\n\n  handleOnScroll({ type, payload }: IInfiniteScrollAction) {\n    switch (type) {\n      case InfiniteScrollActions.DOWN:\n        return this.scrolled.emit(payload);\n\n      case InfiniteScrollActions.UP:\n        return this.scrolledUp.emit(payload);\n\n      default:\n        return;\n    }\n  }\n\n  ngOnDestroy() {\n    this.destroyScroller();\n  }\n\n  destroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { InfiniteScrollDirective } from './infinite-scroll.directive';\n\n@NgModule({\n  declarations: [InfiniteScrollDirective],\n  exports: [InfiniteScrollDirective],\n  imports: [],\n  providers: []\n})\nexport class InfiniteScrollModule { }\n","// Public classes.\nexport {\n  ContainerRef,\n  IInfiniteScrollEvent,\n  IPositionElements,\n  IPositionStats,\n  IResolver\n} from './models';\n\nexport { InfiniteScrollDirective } from './modules/infinite-scroll.directive';\nexport { InfiniteScrollModule } from './modules/ngx-infinite-scroll.module';\n","/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n\n/**\n * Entry point for all public APIs of the package.\n */\nexport * from './src/ngx-infinite-scroll';\n","export * from './public-api';\n"]},"metadata":{},"sourceType":"module"}